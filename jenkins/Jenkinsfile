pipeline {
  agent any
  parameters {
    string(name: 'BUCKET', defaultValue: 'thesamuraibucket', description: 'S3 bucket name')
    string(name: 'KEY', defaultValue: '', description: 'Exact S3 object key (leave blank to auto-find latest)')
  }
  environment {
    AWS_DEFAULT_REGION = 'eu-central-1'
    JENKINS_URL = "${params.jenkins_url ?: 'https://9216d38c2a3f.ngrok-free.app'}"
    TIMESTAMP = "${new Date().format('yyyyMMdd_HHmmss')}"
  }
  stages {
    
    stage('Checkout') {
      steps {
        git url: 'https://github.com/NasriMohamedHedi/terraform-infra.git', branch: 'main'
      }
    }
    stage('Find Payload JSON Key') {
      steps {
        script {
          if (params.KEY?.trim()) {
            echo "Using provided S3 key: ${params.KEY}"
            env.S3_PAYLOAD_KEY = params.KEY.trim()
          } else {
            echo "No S3 key provided, attempting to find latest payload JSON in bucket..."
            def listJson = sh (
              script: "aws s3api list-objects-v2 --bucket ${params.BUCKET} --query 'Contents[?contains(Key, `_ai_output_`) && ends_with(Key, `.json`)] | sort_by(@, &LastModified)[-1].Key' --output text",
              returnStdout: true
            ).trim()
            if (!listJson || listJson == 'None') {
              error "No matching JSON payload files found in S3 bucket ${params.BUCKET}"
            }
            echo "Latest payload JSON key found: ${listJson}"
            env.S3_PAYLOAD_KEY = listJson
          }
        }
      }
    }
    stage('Download Payload JSON') {
      steps {
        withCredentials([[
          $class: 'AmazonWebServicesCredentialsBinding',
          credentialsId: 'aws-terraform-creds',
          accessKeyVariable: 'AWS_ACCESS_KEY_ID',
          secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
        ]]) {
          sh "aws s3 cp s3://${params.BUCKET}/${env.S3_PAYLOAD_KEY} payload.json"
        }
      }
    }
    stage('Parse Payload for Service Type') {
      steps {
        script {
          def payload = readJSON file: 'payload.json'
          env.SERVICE_TYPE = payload.service_type
          echo "Payload JSON loaded:"
          echo "  User Name: ${payload.user_name}"
          echo "  Service Type: ${env.SERVICE_TYPE}"
          echo "  Instances: ${payload.instances.keySet()}"
        }
      }
    }
    stage('Terraform Init') {
  steps {
    withCredentials([
      [$class: 'AmazonWebServicesCredentialsBinding',
      credentialsId: 'aws-terraform-creds',
      accessKeyVariable: 'AWS_ACCESS_KEY_ID',
      secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']
    ]) {
      script {
        def serviceType = readJSON(file: 'payload.json').service_type

        if (serviceType == 'ec2') {
          sh '''
            cp backends/backend-ec2.tf backend.tf
          '''
        } else if (serviceType == 'eks') {
          sh '''
            cp backends/backend-eks.tf backend.tf
          '''
        } else {
          error "Unsupported service type: ${serviceType}"
        }

        sh 'terraform init -input=false -reconfigure'
      }
    }
  }
}

    stage('Terraform Apply') {
      steps {
        withCredentials([[
          $class: 'AmazonWebServicesCredentialsBinding',
          credentialsId: 'aws-terraform-creds',
          accessKeyVariable: 'AWS_ACCESS_KEY_ID',
          secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
        ]]) {
          script {
            def payload = readJSON file: 'payload.json'
            echo "Service Type detected: ${env.SERVICE_TYPE}"
            if (env.SERVICE_TYPE == 'ec2') {
              sh """
                terraform apply \
                  -var 's3_payload_bucket=${params.BUCKET}' \
                  -var 's3_payload_key=${env.S3_PAYLOAD_KEY}' \
                  -var 'jenkins_url=${JENKINS_URL}' \
                  -auto-approve
                terraform output -raw private_key_pem > client-access-key.pem
                chmod 400 client-access-key.pem
              """
            } else if (env.SERVICE_TYPE == 'eks') {
              sh """
                terraform apply \
                  -var 's3_payload_bucket=${params.BUCKET}' \
                  -var 's3_payload_key=${env.S3_PAYLOAD_KEY}' \
                  -auto-approve
              """
              def clusterName = sh(script: "terraform output -raw cluster_name", returnStdout: true).trim()
              echo "Cluster created: ${clusterName}"
              sh """
                aws eks update-kubeconfig --name ${clusterName} --region ${AWS_DEFAULT_REGION}
                echo "kubectl cluster-info"
                kubectl cluster-info || true
                kubectl get nodes --all-namespaces || true
              """
            } else {
              error("Invalid or unsupported service_type: ${env.SERVICE_TYPE}")
            }
          }
        }
      }
    }
    stage('Install Tools with Ansible') {
      when {
        expression { env.SERVICE_TYPE == 'ec2' }
      }
      steps {
        withCredentials([[
          $class: 'AmazonWebServicesCredentialsBinding',
          credentialsId: 'aws-terraform-creds',
          accessKeyVariable: 'AWS_ACCESS_KEY_ID',
          secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
        ]]) {
          script {
            def payload = readJSON file: 'payload.json'
            def instance_key = payload.instances.keySet().toArray()[0]
            def ip = sh(
              script: "terraform output -json ec2_public_ips | jq -r '.\"${instance_key}\"'",
              returnStdout: true
            ).trim()
            if (!ip) error("No IP found for instance ${instance_key}")
            def toolsList = payload.instances[instance_key].tools_to_install ?: []
            writeFile file: 'inventory.ini', text: "${ip} ansible_user=ubuntu ansible_ssh_private_key_file=${WORKSPACE}/client-access-key.pem"
            timeout(time: 20, unit: 'MINUTES') {
              retry(3) {
                sh """
                  until ssh -i client-access-key.pem -o StrictHostKeyChecking=no -o ConnectTimeout=10 ubuntu@${ip} 'echo SSH is up'; do
                    echo "Waiting for SSH..."
                    sleep 30
                  done
                """
              }
            }
            ansiblePlaybook(
              playbook: 'ansible/install_tools.yml',
              inventory: 'inventory.ini',
              extraVars: [
                tools_to_install: toolsList
              ]
            )
          }
        }
      }
    }
    stage('Send SSH Details') {
      when {
        expression { env.SERVICE_TYPE == 'ec2' }
      }
      steps {
        script {
          def payload = readJSON file: 'payload.json'
          def instance_key = payload.instances.keySet().toArray()[0]
          def ip
          withCredentials([[
            $class: 'AmazonWebServicesCredentialsBinding',
            credentialsId: 'aws-terraform-creds',
            accessKeyVariable: 'AWS_ACCESS_KEY_ID',
            secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
          ]]) {
            ip = sh(
              script: "terraform output -json ec2_public_ips | jq -r '.\"${instance_key}\"'",
              returnStdout: true
            ).trim()
          }
          if (!ip) error("No IP found for instance ${instance_key}")
          def clientEmail = payload.client_email
          archiveArtifacts artifacts: 'client-access-key.pem'
          emailext(
            to: clientEmail,
            replyTo: 'no-reply@apollo-dojo.com',
            subject: "üîë Your VM SSH Credentials",
            body: """\
Hello,

Your EC2 instance is up and running. Follow these steps:

Download the private key (attached):  
client-access-key.pem

Secure the key:  
chmod 400 client-access-key.pem

Connect over SSH:  
ssh -i client-access-key.pem ubuntu@${ip}  
Type ‚Äúyes‚Äù if prompted.

Troubleshooting:  
- Ensure the IP (${ip}) is correct and port 22 is open.  
- Verify key permissions with ls -l client-access-key.pem.

Cheers,  
The Apollo Dojo Samurai Team
""",
            attachmentsPattern: 'client-access-key.pem',
            mimeType: 'text/plain'
          )
        }
      }
    }
  }
  post {
    always {
      sh 'rm -f /tmp/client-access-key.pem outputs.json client-access-key.pem payload.json inventory.ini || true'
    }
    success {
      echo "Pipeline completed successfully!"
    }
    failure {
      echo "Pipeline failed. Check logs for details."
    }
  }
}

