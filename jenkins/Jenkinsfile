pipeline {
  agent any
  parameters {
    string(name: 'BUCKET', defaultValue: 'thesamuraibucket', description: 'S3 bucket name')
    string(name: 'KEY', defaultValue: '', description: 'S3 object key')
  }
  environment {
    AWS_DEFAULT_REGION = 'eu-central-1'
    JENKINS_URL = "${params.jenkins_url ?: 'https://9216d38c2a3f.ngrok-free.app'}"
  }
  stages {
    stage('Checkout') {
      steps {
        git url: 'https://github.com/NasriMohamedHedi/terraform-infra.git', branch: 'main'
      }
    }
    stage('Terraform Init') {
      steps {
        withCredentials([[
          $class: 'AmazonWebServicesCredentialsBinding',
          credentialsId: 'aws-terraform-creds',
          accessKeyVariable: 'AWS_ACCESS_KEY_ID',
          secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
        ]]) {
          sh 'terraform init -input=false -reconfigure'
        }
      }
    }
    stage('Terraform Apply') {
      steps {
        withCredentials([[
          $class: 'AmazonWebServicesCredentialsBinding',
          credentialsId: 'aws-terraform-creds',
          accessKeyVariable: 'AWS_ACCESS_KEY_ID',
          secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
        ]]) {
          sh "terraform apply -var 's3_payload_bucket=${BUCKET}' -var 's3_payload_key=${KEY}' -var 'jenkins_url=${JENKINS_URL}' -auto-approve"
        }
      }
    }
    stage('Generate Key Pair') {
      steps {
        withCredentials([[
          $class: 'AmazonWebServicesCredentialsBinding',
          credentialsId: 'aws-terraform-creds',
          accessKeyVariable: 'AWS_ACCESS_KEY_ID',
          secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
        ]]) {
          sh '''
            # Check if key pair exists
            if ! aws ec2 describe-key-pairs --key-names client-access-key --region eu-central-1 >/dev/null 2>&1; then
              aws ec2 create-key-pair --key-name client-access-key --region eu-central-1 --query 'KeyMaterial' --output text > /tmp/client-access-key.pem
              chmod 400 /tmp/client-access-key.pem
              # Copy to a secure location accessible by Jenkins
              sudo cp /tmp/client-access-key.pem /var/lib/jenkins/client-access-key.pem
              sudo chmod 400 /var/lib/jenkins/client-access-key.pem
            else
              echo "Key pair client-access-key already exists"
            fi
          '''
        }
      }
    }
    stage('Archive Outputs') {
      steps {
        withCredentials([[
          $class: 'AmazonWebServicesCredentialsBinding',
          credentialsId: 'aws-terraform-creds',
          accessKeyVariable: 'AWS_ACCESS_KEY_ID',
          secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
        ]]) {
          sh 'terraform output -json > outputs.json'
          archiveArtifacts artifacts: 'outputs.json'
        }
      }
    }
    stage('Send SSH Details') {
      steps {
        withCredentials([usernamePassword(credentialsId: 'gmail-smtp-creds', usernameVariable: 'SMTP_USERNAME', passwordVariable: 'SMTP_PASSWORD'),
                        [$class: 'AmazonWebServicesCredentialsBinding',
                         credentialsId: 'aws-terraform-creds',
                         accessKeyVariable: 'AWS_ACCESS_KEY_ID',
                         secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
          script {
            dir("${WORKSPACE}") {
              // Extract all public IPs from ec2_public_ips map
              def instance_dns = sh(script: "terraform output -json | jq -r '.ec2_public_ips | values[]'", returnStdout: true).trim()
              if (!instance_dns) {
                error "Failed to retrieve instance DNS from Terraform output."
              }
              // Extract the top-level client_email
              def client_email = sh(script: "aws s3 cp s3://${BUCKET}/${KEY} - | jq -r '.client_email'", returnStdout: true).trim()
              if (!client_email || client_email == 'null') {
                error "Failed to retrieve client email from S3 object s3://${BUCKET}/${KEY}."
              }
              // Generate SSH commands for each IP
              def ip_list = instance_dns.split('\n')
              def ssh_commands = ip_list.collect { ip ->
                "ssh -i client-access-key.pem ubuntu@${ip}"
              }.join('\n')
              def instructions = """
              Your VMs have been deployed. Use the following SSH commands to connect:
              ${ssh_commands}
              Instructions:
              1. Save the attached client-access-key.pem file.
              2. Set permissions: chmod 400 client-access-key.pem
              3. Run each command above from your terminal for the respective VM.
              """
              emailext (
                to: client_email,
                subject: "VM Deployment - SSH Access Details",
                body: instructions,
                mimeType: 'text/plain',
                attachmentsPattern: '**/*client-access-key.pem', // Corrected Ant GLOB pattern
                configType: 'smtpServer', // Use SMTP server configuration
                smtpHost: 'smtp.gmail.com',
                smtpPort: '587',
                useSsl: false,
                useTls: true,
                authUsernameVariable: 'SMTP_USERNAME',
                authPasswordVariable: 'SMTP_PASSWORD'
              )
            }
          }
        }
      }
    }
  }
  post {
    always {
      sh 'rm -f /tmp/client-access-key.pem outputs.json || true'
    }
    failure {
      echo "Pipeline failed. Check logs for details."
    }
    success {
      echo "Pipeline completed successfully!"
    }
  }
}
