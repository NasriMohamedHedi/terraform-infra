pipeline {
    agent any

    parameters {
        string(name: 'BUCKET', defaultValue: 'thesamuraibucket', description: 'S3 bucket name')
        string(name: 'KEY', defaultValue: '', description: 'Exact S3 object key (leave blank to auto-find latest)')
    }

    environment {
        AWS_DEFAULT_REGION = 'eu-central-1'
        TIMESTAMP = "${new Date().format('yyyyMMdd_HHmmss')}"
    }

    stages {

        stage('Checkout Repository') {
            steps {
                script {
                    checkout([$class: 'GitSCM',
                        branches: [[name: '*/main']],
                        userRemoteConfigs: [[url: 'https://github.com/NasriMohamedHedi/terraform-infra.git']]
                    ])
                }
            }
        }

        stage('Find Payload in S3') {
            steps {
                script {
                    env.S3_PAYLOAD_KEY = params.KEY ?: sh(
                        script: "aws s3 ls s3://${params.BUCKET}/ | sort | tail -n 1 | awk '{print \$4}' || echo ''",
                        returnStdout: true
                    ).trim()

                    if (!env.S3_PAYLOAD_KEY) {
                        error "‚ùå No payload JSON found in bucket ${params.BUCKET}"
                    }

                    echo "‚úÖ Using payload: ${env.S3_PAYLOAD_KEY}"
                }
            }
        }

        stage('Download Payload') {
            steps {
                withCredentials([[
                    $class: 'AmazonWebServicesCredentialsBinding',
                    credentialsId: 'aws-terraform-creds',
                    accessKeyVariable: 'AWS_ACCESS_KEY_ID',
                    secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
                ]]) {
                    sh "aws s3 cp s3://${params.BUCKET}/${env.S3_PAYLOAD_KEY} payload.json"
                }
            }
        }

        stage('Parse Payload') {
            steps {
                script {
                    def payload = readJSON file: 'payload.json'
                    if (!payload.service_type) error "Missing service_type in payload"

                    env.SERVICE_TYPE = payload.service_type
                    echo """
                    üë§ User: ${payload.user_name}
                    üß© Service Type: ${env.SERVICE_TYPE}
                    üì¶ Client Email: ${payload.client_email}
                    """
                }
            }
        }

        stage('Terraform Init') {
            steps {
                withCredentials([[
                    $class: 'AmazonWebServicesCredentialsBinding',
                    credentialsId: 'aws-terraform-creds',
                    accessKeyVariable: 'AWS_ACCESS_KEY_ID',
                    secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
                ]]) {
                    script {
                        def payload = readJSON file: 'payload.json'
                        if (payload.service_type) {
                            sh "cp backends/backend-${payload.service_type}.tf backend.tf || echo 'No backend file for ${payload.service_type}'"
                            sh "terraform init -reconfigure -upgrade -input=false"
                        }
                    }
                }
            }
        }

        stage('Terraform Apply') {
            steps {
                withCredentials([[
                    $class: 'AmazonWebServicesCredentialsBinding',
                    credentialsId: 'aws-terraform-creds',
                    accessKeyVariable: 'AWS_ACCESS_KEY_ID',
                    secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
                ]]) {
                    script {
                        def payload = readJSON file: 'payload.json'
                        echo "üöÄ Applying Terraform for ${payload.service_type}"

                        sh """
                            terraform apply \
                              -var 's3_payload_bucket=${params.BUCKET}' \
                              -var 's3_payload_key=${env.S3_PAYLOAD_KEY}' \
                              -var 'aws_region=${AWS_DEFAULT_REGION}' \
                              -auto-approve
                        """

                        if (payload.service_type == 'ec2') {
                            sh """
                                terraform output -raw private_key_pem > client-access-key.pem
                                chmod 400 client-access-key.pem
                            """
                            archiveArtifacts artifacts: 'client-access-key.pem'
                        }
                    }
                }
            }
        }

        stage('Install Tools on EC2 (Ansible)') {
            when { expression { env.SERVICE_TYPE == 'ec2' } }
            steps {
                withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-terraform-creds']]) {
                    script {
                        def payload = readJSON file: 'payload.json'
                        def instance_name = payload.instances.keySet()[0]
                        def ip = sh(script: "terraform output -json ec2_public_ips | jq -r '.\"${instance_name}\"'", returnStdout: true).trim()

                        echo "üñ• EC2 instance IP: ${ip}"

                        writeFile file: 'inventory.ini', text: """
                        [ec2]
                        ${ip} ansible_user=ubuntu ansible_ssh_private_key_file=client-access-key.pem
                        """

                        def tools = payload.instances[instance_name].tools_to_install ?: []
                        def tools_json = writeJSON returnText: true, json: tools

                        sh "ansible-playbook -i inventory.ini --extra-vars 'tools_to_install=${tools_json}' ansible/install_tools.yml"
                    }
                }
            }
        }

stage('Deploy Tools on EKS') {
    when { expression { env.SERVICE_TYPE == 'eks' } }
    steps {
        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-terraform-creds']]) {
            script {
                def payload = readJSON file: 'payload.json'
                def cluster_name = payload.eks.cluster_name

                echo "‚ò∏ Deploying tools to EKS Cluster: ${cluster_name}"

                // kubeconfig
                def kubeconfig = sh(script: "terraform output -raw eks_kubeconfig", returnStdout: true).trim()
                writeFile file: 'kubeconfig.yaml', text: kubeconfig
                env.KUBECONFIG = "${WORKSPACE}/kubeconfig.yaml"

                // Login to ECR (so helm/chart pulls and local docker login succeed)
                sh """
                    aws ecr get-login-password --region ${AWS_DEFAULT_REGION} | \
                    docker login --username AWS --password-stdin 430118831270.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com
                """

                // Add common repos and update with retries (network can be flaky)
                sh """
                    helm repo add grafana https://grafana.github.io/helm-charts || true
                    helm repo add prometheus https://prometheus-community.github.io/helm-charts || true

                    attempt=0
                    until [ $attempt -ge 5 ]
                    do
                      helm repo update && break
                      attempt=$((attempt+1))
                      echo "helm repo update failed, retry #$attempt ‚Äî sleeping 5s"
                      sleep 5
                    done

                    if [ $attempt -ge 5 ]; then
                      echo "helm repo update failed after retries"
                      helm repo list
                      exit 1
                    fi

                    helm repo list
                """

                // ensure namespace
                sh "kubectl get ns monitoring || kubectl create ns monitoring"

                // create image pull secret using command substitution (kubectl doesn't accept --docker-password-stdin)
                sh """
                    # create secret if not exists (uses aws ecr get-login-password)
                    kubectl get secret ecr-creds -n monitoring >/dev/null 2>&1 || \
                    kubectl create secret docker-registry ecr-creds \
                      --docker-server=430118831270.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com \
                      --docker-username=AWS \
                      --docker-password="$(aws ecr get-login-password --region ${AWS_DEFAULT_REGION})" \
                      --namespace monitoring

                    # patch default serviceaccount in monitoring so pods pick the imagePullSecret (idempotent)
                    kubectl patch serviceaccount default -n monitoring -p '{"imagePullSecrets":[{"name":"ecr-creds"}]}' || true
                """

                // tools list - adjust as needed or generate from payload
                def tools = [
                    [
                        name: "prometheus",
                        repo: "https://prometheus-community.github.io/helm-charts",
                        chart: "prometheus",
                        imageRepo: "430118831270.dkr.ecr.eu-central-1.amazonaws.com/prometheus",
                        namespace: "monitoring"
                    ],
                    [
                        name: "grafana",
                        repo: "https://grafana.github.io/helm-charts",
                        chart: "grafana",
                        imageRepo: "430118831270.dkr.ecr.eu-central-1.amazonaws.com/grafana",
                        namespace: "monitoring"
                    ]
                ]

                tools.each { tool ->
                    def chartRef = tool.chart.contains('/') ? tool.chart : "${tool.chart}"
                    def relName = tool.name
                    def ns = tool.namespace
                    def imageRepo = tool.imageRepo

                    echo "üì¶ Installing ${relName} in namespace ${ns} (chart=${chartRef})"

                    // sanity check: show search results and repo info
                    sh """
                        echo "---- helm search repo for ${chartRef} ----"
                        helm search repo ${chartRef} || true
                        echo "---- helm show chart (attempt) ----"
                        helm show chart ${chartRef} --repo ${tool.repo} || true
                    """

                    // install with retries and debug flags to capture details
                    def installCmd = "helm upgrade --install ${relName} ${chartRef} --namespace ${ns} --repo ${tool.repo} --set image.repository=${imageRepo} --set image.tag=latest --set image.pullPolicy=Always --wait --timeout 15m --debug"

                    sh """
                        attempt=0
                        until [ $attempt -ge 3 ]
                        do
                          echo "Running: ${installCmd}"
                          ${installCmd} && break
                          attempt=$((attempt+1))
                          echo "helm install for ${relName} failed (attempt $attempt). Dumping helm status and waiting 10s before retry."
                          helm status ${relName} -n ${ns} || true
                          kubectl get events -n ${ns} --sort-by='.lastTimestamp' | tail -n 20 || true
                          sleep 10
                        done

                        if [ $attempt -ge 3 ]; then
                          echo "helm install for ${relName} failed after retries ‚Äî printing debug info"
                          helm status ${relName} -n ${ns} || true
                          kubectl get all -n ${ns} || true
                          kubectl describe pod -n ${ns} || true
                          exit 1
                        fi
                    """
                }

                echo "‚úÖ All tools deployed successfully on ${cluster_name}"
            }
        }
    }
}



        stage('Send Kubeconfig via Email') {
            when { expression { env.SERVICE_TYPE == 'eks' } }
            steps {
                script {
                    def payload = readJSON file: 'payload.json'
                    emailext(
                        to: payload.client_email,
                        subject: "EKS Cluster Access: ${payload.eks.cluster_name}",
                        body: """
Hello ${payload.user_name},

Your EKS cluster "${payload.eks.cluster_name}" is ready.

Save the attached kubeconfig file and run:
export KUBECONFIG=kubeconfig.yaml
kubectl get nodes

Regards,  
Samurai DevOps Team
                        """,
                        attachmentsPattern: 'kubeconfig.yaml',
                        mimeType: 'text/plain'
                    )
                }
            }
        }

        stage('Send EC2 SSH Credentials') {
            when { expression { env.SERVICE_TYPE == 'ec2' } }
            steps {
                script {
                    def payload = readJSON file: 'payload.json'
                    def instance_name = payload.instances.keySet()[0]
                    def ip = sh(script: "terraform output -json ec2_public_ips | jq -r '.\"${instance_name}\"'", returnStdout: true).trim()

                    emailext(
                        to: payload.client_email,
                        subject: "üîë SSH Access for Your EC2 Instance",
                        body: """
Hello ${payload.user_name},

Your EC2 instance is ready and reachable at:
ssh -i client-access-key.pem ubuntu@${ip}

Regards,  
Samurai DevOps Team
                        """,
                        attachmentsPattern: 'client-access-key.pem'
                    )
                }
            }
        }
    }

    post {
        always {
            sh 'rm -f client-access-key.pem payload.json kubeconfig.yaml inventory.ini || true'
        }
        success { echo "‚úÖ Pipeline completed successfully!" }
        failure { echo "‚ùå Pipeline failed ‚Äî check logs." }
    }
}

